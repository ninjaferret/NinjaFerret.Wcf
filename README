h1. NinjaFerret.Wcf

This is a system for automatically generating an "invisible" proxy 
client for a WCF service. The aim is that the client factory will 
generate something that looks exactly like the service, that the 
service and the client are interchangeable and that the client will
not need to know (barring configuration) about whether it is using
the service in-line or as a WCf service.

h2. NinjaFerret.Wcf.Client

This is the actual client factory that will generate a client at 
runtime for you. The sample application contains examples of the 
Castle Windsor configuration to call into the factory.

Simply put even within your own code you can create a factory for
each type of interface and call:

clientFactory.GenerateClient();

If you wish to use two different endpoints for a single interface then
use:

clientFactory.GenerateClient(endpointName);

This will generate you a distinct proxy client using the given endpoint
name that is specified in the config file. 

h2. NinjaFerret.Wcf.Exeption

This is a small assembly used to support you when using the ClientFactory
to translate exceptions across the WCF interface boundary. 

Any exception that you wish to throw across the boundary should be defined
on the service contract using a fault that inherits from:

NinjaFerret.Wcf.Exception.TranslatableFault

This fault should have an equivalent exception that implements:

NinjaFerret.Wcf.Exception.ITranslatableException

The client that is generated by the ClientFactory will intercept any
TranslatableFaults and convert them back into the exceptions that were
originally thrown.

In the sample application describes my idea situation, the actual service
that does the work is maintained in an assembly separate from the service host.
When hosting the service in WCF create a wrapper class that translates these
exceptions into faults... the client never needs to change.